#pragma kernel PrepareLights

#include "Packages/com.unity.render-pipelines.universal@14.0.9/ShaderLibrary/Core.hlsl"
#include "Packing.hlsl"
#include "ShaderParameters.hlsl"
#include "TriangleLight.hlsl"

uint numTasks;

struct TriangleLightDebug
{
    float3 base;
    float3 v1;
    float3 v2;
    float3 edge1;
    float3 edge2;
    float3 radiance;
};

StructuredBuffer<PrepareLightsTask>     TaskBuffer;
StructuredBuffer<TriangleLightVertex>   LightVertexBuffer;
StructuredBuffer<int>                   LightIndexBuffer;
RWStructuredBuffer<RAB_LightInfo>       LightDataBuffer;
RWStructuredBuffer<TriangleLightDebug>       TriangleLightDebugBuffer;

bool FindTask(uint dispatchThreadId, out PrepareLightsTask task)
{
    // Use binary search to find the task that contains the current thread's output index:
    //   task.lightBufferOffset <= dispatchThreadId < (task.lightBufferOffset + task.triangleCount)

    int left = 0;
    int right = int(numTasks) - 1;

    while (right >= left)
    {
        int middle = (left + right) / 2;
        task = TaskBuffer[middle];

        int tri = int(dispatchThreadId) - int(task.lightBufferOffset); // signed

        if (tri < 0)
        {
            // Go left
            right = middle - 1;
        }
        else if (tri < task.triangleCount)
        {
            // Found it!
            return true;
        }
        else
        {
            // Go right
            left = middle + 1;
        }
    }

    return false;
}

// 每个线程要处理一个三角形（一次性从global vertex buffer里拿出三个顶点）
[numthreads(256, 1, 1)]
void PrepareLights (uint dispatchThreadId : SV_DispatchThreadID, uint groupThreadId : SV_GroupThreadID)
{
    // 每一个task处理的是一个polymorphic light，这意味着一个task内会包含多个三角形
    PrepareLightsTask task = (PrepareLightsTask)0;

    // 每个线程（三角形）都需要找到属于自己的那一个task
    if (!FindTask(dispatchThreadId, task))
        return;

    uint triangleIdx = dispatchThreadId;

    RAB_LightInfo lightInfo = (RAB_LightInfo)0;

    TriangleLightDebug triangle_light_debug = (TriangleLightDebug)0;

    {
        int indices[3];
        indices[0] = LightIndexBuffer[3 * triangleIdx + 0];
        indices[1] = LightIndexBuffer[3 * triangleIdx + 1];
        indices[2] = LightIndexBuffer[3 * triangleIdx + 2];
        
        TriangleLightVertex vertices[3];
        vertices[0] = LightVertexBuffer[task.lightBufferOffset + indices[0]];
        vertices[1] = LightVertexBuffer[task.lightBufferOffset + indices[1]];
        vertices[2] = LightVertexBuffer[task.lightBufferOffset + indices[2]];

        float3 worldPos0 = mul(task.localToWorld, float4(vertices[0].position, 1.0)).xyz;
        float3 worldPos1 = mul(task.localToWorld, float4(vertices[1].position, 1.0)).xyz;
        float3 worldPos2 = mul(task.localToWorld, float4(vertices[2].position, 1.0)).xyz;

        float3 radiance = max(task.emissiveColor, 0.0f);

        TriangleLight triLight;
        triLight.base       = worldPos0;
        triLight.edge1      = worldPos1 - worldPos0;
        triLight.edge2      = worldPos2 - worldPos0;
        triLight.radiance   = radiance;

        triangle_light_debug.base       = worldPos0;
        triangle_light_debug.v1         = worldPos1;
        triangle_light_debug.v2         = worldPos2;
        triangle_light_debug.edge1      = triangle_light_debug.v1 - triangle_light_debug.base;
        triangle_light_debug.edge2      = worldPos2 - worldPos0;
        triangle_light_debug.radiance   = triLight.radiance;

        lightInfo = triLight.Store();
    }

    const uint lightBufferPtr                   = dispatchThreadId;
    LightDataBuffer[lightBufferPtr]             = lightInfo;
    TriangleLightDebugBuffer[lightBufferPtr]    = triangle_light_debug;
}
